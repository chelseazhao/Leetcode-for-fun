307 Range Sum Query - Mutable

Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
The update(i, val) function modifies nums by updating the element at index i to val.

Example:

Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8

Note:

1. The array is only modifiable by the update function.
2. You may assume the number of calls to update and sumRange function is distributed evenly.

思路：1. 线段树(Segment Tree)
线段树的表示：
1. 叶子节点存储输入的数组元素
2. 每一个内部节点表示某些叶子节点的合并(merge)。合并的方法可能会因问题而异。对于这个问题，合并指的是某个节点之下的所有叶子节点的和。
此处使用树的数组形式来表示线段树。对于下标i的节点，其左孩子为 2*i+1，右孩子为2*i+2，父节点为floor( (i - 1)/2 )

根据给定的数组构建线段树：
我们从线段数组arr[0 . . . n-1]开始。每一次将现有的线段拆分成两半（如果当前线段的长度还不为1），然后在两半线段分别执行同样的过程，并且对于每一个这样的线段，我们存储相应节点的和。
构建出的线段树除最后一层外每一层都会填满。线段树是满二叉树（此处的满二叉树是指树中任意节点的度为0或2的二叉树，与国内计算机教材关于满二叉树的定义不同），因为我们在每一层都将线段拆分为两半。由于构建出的树总是拥有n个叶子节点的满二叉树，因此内部节点会有 n-1 个。因而节点总数为 2*n - 1。
线段树的高度为ceil( log n )。由于树使用数组表示，并且需要维护父子索引之间的关系，为线段树分配的内存需要：2 * 2 ^ ceil( logn ) - 1

线段树构建的时间复杂度为O(n)。总计有2n-1个节点， 每一个节点在树构建过程中只被运算一次。
查询的时间复杂度为O(log n)。 要查询区间和， 我们在每一层至多处理4个节点，并且层的总数为O(log n)。
更新的时间复杂度也是O(log n)。 要更新一个叶子节点， 我们每一层处理一个节点，并且层的总数为O(log n)。

转自http://bookshadow.com/weblog/2015/08/13/segment-tree-set-1-sum-of-given-range/

2. 树状数组(Binary Indexed Tree)
1.“树状数组”数据结构的一种应用

　　对含有n个元素的数组(a[1],...,a[k],...,a[n])：

　　(1)求出第i个到第j个元素的和，sum=a[i]+...+a[j]。

　　　　进行j-i+1次加法，复杂度为O(j-i+1)

　　(2)任意修改其中某个元素的值。

　　　　使用数组下标可以直接定位修改，时间复杂度为O(1)

 　　对于同时支持上述两种操作的系统中，求和操作(1)求任意连续个数组元素和的平均时间复杂度为O(n)，修改操作(2)时间复杂度是O(1)。如果系统中大量进行上述两种操作m次，其中执行操作(1)概率1/p，操作(2)概率1-1/p，则系统时间复杂度为：

　　可以使用树状数组使得上述两种操作的时间复杂度为O(m*logn)。

2.树状数组介绍

　　核心思想：

　　　　(1)树状数组中的每个元素是原数组中一个或者多个连续元素的和。

　　　　(2)在进行连续求和操作a[1]+...+a[n]时，只需要将树状数组中某几个元素的和即可。时间复杂度为O(lgn)

　　　　(3)在进行修改某个元素a[i]时，只需要修改树状数组中某几个元素的和即可。时间复杂度为O(lgn)

　　下图就是一个树状数组的示意图：

　　解释如下：

　　1)　a[]: 保存原始数据的数组。(操作(1)求其中连续多个数的和，操作(2)任意修改其中一个元素)

　　　　e[]: 树状数组，其中的任意一个元素e[i]可能是一个或者多个a数组中元素的和。如e[2]=a[1]+a[2]; e[3]=a[3]; e[4]=a[1]+a[2]+a[3]+a[4]。 

　　2） e[i]是几个a数组中的元素的和？

　　　　如果数字 i 的二进制表示中末尾有k个连续的0，则e[i]是a数组中2^k个元素的和，则e[i]=a[i-2^k+1]+a[i-2^k+2]+...+a[i-1]+a[i]。

　　　　如：4=100(2)　　e[4]=a[1]+a[2]+a[3]+a[4];

　　　　　　6=110(2)　　e[6]=a[5]+a[6]

　　　　　　7=111(2)　　e[7]=a[7]

　　3)　后继：可以理解为节点的父亲节点。是离它最近的，且编号末位连续0比它多的就是它的父亲,如e[2]是e[1]的后继；e[4]是e[2]的后继。

　　　　　　如e[4] = e[2]+e[3]+a[4] = a[1]+a[2]+a[3]+a[4] ，e[2]、e[3]的后继就是e[4]。

　　　　　　后继主要是用来计算e数组，将当前已经计算出的e[i]添加到他们后继中。

　　　　前驱：节点前驱的编号即为比自己小的，最近的，最末连续0比自己多的节点。如e[7]的前驱是e[6],e[6]的前驱是e[4]。

 　　　　　  前驱主要是在计算连续和时，避免重复添加元素。

　　　　　　如：Sum(7)=a[1]+...+a[7]=e[7]+e[6]+e[4]。(e[7]的前驱是e[6], e[6]的前驱是e[4])

　　　　计算前驱与后继：

　　　　　　lowbit(i) = ( (i-1) ^ i) & i ;

　　　　　　节点e[i]的前驱为 e[ i - lowbit(i) ]；

　　　　　　节点e[i]的前驱为 e[ i + lowbit(i) ]

转自：http://www.cnblogs.com/xudong-bupt/p/3484080.html